''' Script to produce csv files to use as reference (gold) for moose unittests
    from csv files generated by XXX.py from an Abaqus odb database.
'''

import os, sys, csv

def odbcsv2goldcsv(in_filename, output_dir, properties):
    ''' Function to convert data from full csv to gold csv (overwriting csv file)
      @param[in] in_filename - string, path of input full csv file
      @param[in] output_dir - string, path of export directory
      @param[in] properties - list of strings, properties to export
    '''
    print 'Overwriting file "{0}" in Redback format'.format(in_filename)
    # Check if export directory exists
    if not os.path.isdir(output_dir):
        os.makedirs(output_dir)
    # Read input csv file
    data_rows = []
    headers = None
    dim = None
    with open(in_filename, 'rb') as csvfile:
        reader = csv.reader(csvfile)
        index_row = 0
        for row in reader:
            if index_row == 0:
                # Reading information (element index and integration point)
                dim = int(row[1])
                print 'Dimensionality: {0}, Element index: {1}, integration point: {2}'\
                    .format(dim, row[3], row[5])
            elif index_row == 1:
                # Grab all headers
                headers = row
            else:
                # Reading data line
                data_rows.append(row)
            index_row += 1
    nb_data_lines = index_row - 2
    # Overwrite csv file
    with open(in_filename, 'wb') as csvfile: 
        writer = csv.writer(csvfile)
        # Headers
        new_headers = ['time']
        new_headers.extend([getNiceName(elt, dim) for elt in properties])
        writer.writerow(new_headers)
        # Data
        for j in range(nb_data_lines):
            line_index = j + 2
            line_data = [data_rows[j][1]]
            for property in properties:
                col_index = headers.index(property)
                line_data.append(data_rows[j][col_index])
            writer.writerow(line_data)
    print 'File "{0}" overwritten'.format(in_filename)

def odbcsv2goldcsvIndependentFiles(in_filename, output_dir):
  ''' Function to convert data from full csv to gold csv
      @param[in] in_filename - string, path of input full csv file
      @param[in] output_dir - string, path of export directory
  '''
  print 'Converting file "{0}"'.format(in_filename)
  # Check if export directory exists
  if not os.path.isdir(output_dir):
    os.makedirs(output_dir)
  # Read input csv file
  data_rows = []
  headers = None
  dim = None
  with open(in_filename, 'rb') as csvfile:
    reader = csv.reader(csvfile)
    index_row = 0
    for row in reader:
      if index_row == 0:
        # Reading information (element index and integration point)
        dim = int(row[1])
        print 'Dimensionality: {0}, Element index: {1}, integration point: {2}'\
          .format(dim, row[3], row[5])
      elif index_row == 1:
        # Grab all headers
        headers = row
      else:
        # Reading data line
        data_rows.append(row)
      index_row += 1
  nb_data_lines = index_row - 2
  # Create individual csv files
  nb_files = len(headers) - 2
  for i in range(nb_files):
    col_index = i + 2
    data_name = headers[col_index]
    shortrootfilename = '{0}'.format(getNiceName(data_name, dim))
    root_in_filename = os.path.splitext(os.path.split(in_filename)[1])[0]
    shortfilename = root_in_filename + '_' + shortrootfilename + '.csv'
    filename = os.path.join(output_dir, shortfilename)
    with open(filename, 'wb') as csvfile:
      writer = csv.writer(csvfile)
      writer.writerow(['time', shortrootfilename])
      for j in range(nb_data_lines):
        line_index = j + 2
        writer.writerow([data_rows[j][1], data_rows[j][col_index]])
    print 'File "{0}" generated'.format(filename)
  print 'Finished'

def getNiceName(name, dim):
  ''' Return nicer name to be used as file name
      @param[in] name - string, name to modify
      @param[in] dim - int, dimensionality of the problem
      @return[out] nice_name - string, modified name
  '''
  nice_name = name.replace(' ', '_')
  nice_name = name.replace('.', '_')
  if dim == 2:
    real_tensor_indices = {
      1:'11',
      2:'22',
      3:'33',
      4:'21'
    }
  elif dim == 3:
    real_tensor_indices = { # TODO: check the order!!!
      1:'11',
      2:'22',
      3:'33',
      4:'12',
      5:'13',
      6:'23'
    }
  else:
    error_msg = 'Dimension {0} not handled!'.format(dim)
    raise Exception, error_msg
  if name.lower().strip().endswith(']'):
    j = nice_name.rindex('[')
    tensor_index = int(nice_name[j+1:-1])
    nice_name = nice_name[0:j] + '_' + real_tensor_indices[tensor_index]
  return nice_name

if __name__ == "__main__":
  odbcsv2goldcsv('C:\\Users\\OlivierSimonnot\\Dropbox\\UNSW\\Abaqus\\benchmarks\\benchmark_3_M\\bench_elastic_1\\bench_abaqus_elastic_01.csv', 
                 os.path.join(dir_path, os.path.splitext(output_csv_filename)[0]),
                 properties=['S.Mises', 'S.Pressure'])
